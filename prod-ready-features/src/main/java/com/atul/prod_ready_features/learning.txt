ğŸ“Œ 1. Overview â€” What is Database Auditing?
ğŸ”¹ Definition

In ORM context, database auditing means:

Tracking and logging INSERT, UPDATE, DELETE operations performed on persistent entities.

It is similar to:

Git version control

Database triggers

Entity versioning

ğŸ”¹ Why Auditing?

Auditing helps to:

Track who changed data

Track when data changed

Track what changed

Maintain historical versions

Enable rollback

Ensure compliance

ğŸ“Œ 2. Auditing With Pure JPA (Jakarta Persistence)

JPA does NOT provide a dedicated auditing API.

We implement auditing using:

Entity Lifecycle Callbacks

ğŸ”¹ 2.1 Lifecycle Callback Annotations

These methods run automatically during entity lifecycle events.

Annotation	Triggered Before
@PrePersist	INSERT
@PreUpdate	UPDATE
@PreRemove	DELETE

Example:

@Entity
public class Bar {

    @PrePersist
    public void beforeInsert() {}

    @PreUpdate
    public void beforeUpdate() {}

    @PreRemove
    public void beforeDelete() {}
}

ğŸ”¹ Rules for Callback Methods

Must return void

Must have no parameters

Cannot be static

Any visibility allowed

Can have any name

ğŸ”¹ Important Restriction (Very Important)

JPA Spec says:

Lifecycle methods must NOT:

Call EntityManager

Run queries

Modify relationships

Access other entities

They can ONLY:

Modify non-relationship fields of the same entity

Why?

Because callbacks run during flush cycle, and modifying relationships can break persistence consistency.

ğŸ”¹ Example Manual Auditing (Pure JPA)
@Column(name="operation")
private String operation;

@Column(name="timestamp")
private long timestamp;

@PrePersist
public void onInsert() {
    audit("INSERT");
}

private void audit(String op) {
    this.operation = op;
    this.timestamp = System.currentTimeMillis();
}

ğŸ”¹ Centralizing with @EntityListeners

Instead of repeating callbacks in every entity:

@EntityListeners(AuditListener.class)
@Entity
public class Bar {}


Listener:

public class AuditListener {

    @PrePersist
    @PreUpdate
    @PreRemove
    private void beforeAnyOperation(Object entity) {}
}


This centralizes lifecycle logic.

ğŸ”¹ Limitation of Pure JPA Auditing

Cannot audit DELETE properly (entity gets removed)

Cannot track full history

Must manually manage schema

Limited to non-relationship state

ğŸ“Œ 3. Hibernate Envers

Envers is a Hibernate module for:

Full entity versioning and historical tracking.

ğŸ”¹ 3.1 Setup

Add dependency:

<dependency>
    <groupId>org.hibernate.orm</groupId>
    <artifactId>envers</artifactId>
</dependency>


Add annotation:

@Entity
@Audited
public class Bar {}

ğŸ”¹ Important Rule

Auditing is PER ENTITY.

If:

Bar has relation to Foo


Then:

Foo must also be annotated with @Audited


If you want its history tracked.

ğŸ”¹ 3.2 What Tables Are Created?

If Bar is audited:

Envers creates:

bar
bar_AUD
REVINFO


If Foo is audited:

foo
foo_AUD

ğŸ”¹ Audit Table Structure

Audit table contains:

All entity columns +

REV
REVTYPE

REVTYPE Values
Value	Meaning
0	INSERT
1	UPDATE
2	DELETE
ğŸ”¹ REVINFO Table

Structure:

REV        (primary key)
REVTSTMP   (timestamp)


Important:

One revision per transaction

All changes in same transaction share same REV

_AUD.REV â†’ foreign key to REVINFO.REV

This creates a one-to-many relationship:

One REVINFO â†’ Many Audit Entries

ğŸ”¹ 3.3 Configuration

Example:

Change audit table suffix:

org.hibernate.envers.audit_table_suffix=_AUDIT_LOG

ğŸ”¹ 3.4 Reading Audit History

Obtain reader:

AuditReader reader = AuditReaderFactory.get(entityManager);


Get entity at revision:

reader.find(Bar.class, id, revisionNumber);


Get all revisions:

reader.createQuery()
      .forRevisionsOfEntity(Bar.class, true, true);

ğŸ”¹ Advantages of Envers

Full history

Delete auditing supported

Per-transaction revision tracking

Production-ready

ğŸ”¹ Limitation

Hibernate specific

Not pure JPA

ğŸ“Œ 4. Spring Data JPA Auditing

Spring Data abstracts JPA lifecycle and provides simple annotations.

ğŸ”¹ 4.1 Enable Auditing
@EnableJpaAuditing


Usually on:

@SpringBootApplication

ğŸ”¹ 4.2 Add Entity Listener
@Entity
@EntityListeners(AuditingEntityListener.class)
public class Bar {}


This listener internally handles lifecycle.

ğŸ”¹ 4.3 Date Tracking
@CreatedDate
private LocalDateTime createdDate;

@LastModifiedDate
private LocalDateTime modifiedDate;


These are auto-populated.

ğŸ”¹ 4.4 User Tracking
@CreatedBy
private String createdBy;

@LastModifiedBy
private String modifiedBy;


These get values from AuditorAware.

ğŸ”¹ AuditorAware Interface
public class AuditorAwareImpl implements AuditorAware<String> {

    @Override
    public Optional<String> getCurrentAuditor() {
        return Optional.of("Atul");
    }
}

ğŸ”¹ Register Auditor Bean
@EnableJpaAuditing(auditorAwareRef="auditorProvider")

@Bean("auditorProvider")
public AuditorAware<String> auditorProvider() {
    return new AuditorAwareImpl();
}

ğŸ”¹ How It Works Internally
persist()
â†’ PrePersist event
â†’ AuditingEntityListener runs
â†’ It calls AuditorAware
â†’ Sets createdBy / modifiedDate
â†’ SQL executes

ğŸ”¹ Limitation

Same as pure JPA:

DELETE cannot be fully audited

No history table

Only stores current state

ğŸ“Œ 5. Comparison
Feature	Pure JPA	Envers	Spring Data
Insert audit	âœ…	âœ…	âœ…
Update audit	âœ…	âœ…	âœ…
Delete audit	âŒ (entity removed)	âœ…	âŒ
Full history	âŒ	âœ…	âŒ
Versioning	âŒ	âœ…	âŒ
Easy config	âŒ	Medium	âœ…
Security integration	âŒ	âŒ	âœ…
ğŸ“Œ Final Mental Model

There are three levels:

1ï¸âƒ£ Pure JPA

Basic lifecycle hooks.

2ï¸âƒ£ Spring Data

Cleaner abstraction of JPA lifecycle.

3ï¸âƒ£ Envers

True versioned history tracking system.



---------------
Example flow
---------------
ğŸ§  First â€” What Is Actually Happening When /posts/9(means posts which is not present) Is Called?

Letâ€™s assume:

There is NO post with id = 9.

ğŸ” Step 1 â€” Request Comes In

Client calls:

GET /posts/9


Spring does:

Controller â†’ Service â†’ Repository

ğŸ” Step 2 â€” Repository
postRepository.findById(9)


Returns:

Optional.empty()


Because no row exists.

ğŸ” Step 3 â€” Service
.orElseThrow(...)

This line executes.

Since Optional is empty:

â†’ It THROWS an exception.

Letâ€™s say:

new ResourceNotFoundException("Post", "id", 9)


Boom ğŸ’¥
Execution stops immediately.

Nothing after that line runs.

ğŸš¨ Now Important Question

Where does this exception go?

It starts going UP the call stack.

Like this:

Repository
  â†‘
Service
  â†‘
Controller
  â†‘
Spring DispatcherServlet

ğŸ§  If We Did NOTHING

Spring sees:

"Some runtime exception happened"

So it says:

Server error.

And returns:

500 Internal Server Error


Because Spring does not know what that exception means.

ğŸ”¥ Now Where Does @RestControllerAdvice Come In?

Think of it like this:

Spring has a global try-catch mechanism.

Very important:

Spring internally wraps controller execution in something like:

try {
    controllerMethod();
}
catch (Exception e) {
    handleException(e);
}


That handleException(e) part looks for:

Any class annotated with @ControllerAdvice or @RestControllerAdvice

Any method annotated with @ExceptionHandler(SomeException.class)

ğŸ§© So When Exception Is Thrown

Flow becomes:

Controller
   â†“
Service
   â†“
Repository
   â†“
Exception Thrown
   â†‘
Spring catches it
   â†“
Looks for matching @ExceptionHandler
   â†“
Calls that method
   â†“
Returns ResponseEntity

ğŸ¯ Letâ€™s Visualize It Clearly
WITHOUT Global Advice
Client â†’ Controller â†’ Service â†’ Exception
                           â†‘
                       Nobody catches
                           â†‘
                   Spring default handler
                           â†‘
                    500 Internal Server Error

WITH Global Advice
Client â†’ Controller â†’ Service â†’ Exception
                           â†‘
                    Spring catches it
                           â†‘
         Finds @ExceptionHandler(ResourceNotFoundException)
                           â†‘
               Calls your method in GlobalExceptionHandler
                           â†‘
                Returns custom 404 response

ğŸ”¥ Now Letâ€™s See Concrete Code Flow
Step A â€” Exception Thrown
.orElseThrow(() ->
        new ResourceNotFoundException("Post", "id", postId)
);


This creates:

ResourceNotFoundException

Step B â€” Spring Sees This Class

You wrote:

@RestControllerAdvice
public class GlobalExceptionHandler


Spring scans this at startup.

It registers:

â€œIf any controller throws ResourceNotFoundException, call this method.â€

Step C â€” Exception Handler Method
@ExceptionHandler(ResourceNotFoundException.class)
public ResponseEntity<ErrorDetails> handleResourceNotFound(
        ResourceNotFoundException ex) {


Spring matches:

Exception type = ResourceNotFoundException
Handler expects = ResourceNotFoundException

Match found âœ…

Spring calls this method.

Step D â€” Your Handler Returns
return new ResponseEntity<>(error, HttpStatus.NOT_FOUND);


Now Spring says:

Oh, you want to send 404.

So it builds:

HTTP 404
JSON body = ErrorDetails


And sends to client.

ğŸ§  IMPORTANT

You did NOT call this method manually.

Spring calls it automatically because:

It is annotated

It matches exception type

It is global advice

ğŸ§  Why Is It Called â€œAdviceâ€?

Because it â€œadvisesâ€ the controller globally.

It acts like:

A global interceptor for exceptions.

ğŸ”¥ Real Life Analogy

Imagine:

Controller = Office worker
Service = Assistant
Exception = Complaint

Without Advice:

Complaint reaches office â†’ Nobody knows what to do â†’ Panic â†’ 500

With Advice:

Complaint reaches office â†’ Reception desk (Advice) handles it properly â†’ Sends correct response

ğŸ§  End-to-End Flow in One Line
Exception thrown â†’ Spring catches â†’ matches handler â†’ handler returns ResponseEntity â†’ client receives formatted HTTP response


ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥

Auditing

ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥

------------
jpa auditing
-------------

Uses lifecycle events to cater basic auditing needs

----------------
Hibernate envers
----------------

First: Which Auditing Are We Talking About?

The annotation:

@Audited


belongs to Hibernate Envers, not Spring Data auditing.

Envers does something different:

It stores historical versions of entities in separate audit tables.

So if you have:

@Entity
@Audited
public class Foo { }


Hibernate creates:

foo
foo_AUD


Where:

foo â†’ current data

foo_AUD â†’ history of changes

ğŸ§  Now Your Real Question

You asked:

If two entities are in relationship and we audit one, must we audit the other?

Answer:

âŒ Not mandatory
âœ… But depends on what you want to track

ğŸ” Letâ€™s Use Example
@Entity
@Audited
public class Bar {

    @OneToMany(mappedBy = "bar")
    private List<Foo> foos;
}


and:

@Entity
public class Foo {

    @ManyToOne
    private Bar bar;
}

ğŸ”¥ Case 1 â€” Only Bar Is Audited

What happens?

Changes to Bar are tracked.

Relationship changes may or may not be tracked fully.

Changes inside Foo are NOT tracked.

If you update a Foo field:

foo.setName("New Name")


No audit record is created for Foo.

Because Foo is not audited.

ğŸ”¥ Case 2 â€” Both Are Audited
@Entity
@Audited
public class Foo { }


Now:

Foo has its own audit table.

Every update to Foo is stored in foo_AUD.

This gives full history.

ğŸ§  Why Would We Need to Audit Both?

Because:

Auditing Bar does NOT automatically audit Foo.

Each entity is audited independently.

Relationship changes are tracked only if both sides are audited.

ğŸ§  Important Subtle Point

If Bar is audited and Foo is not:

Envers will still track relationship changes in Bar's audit table.

But:

It will NOT store historical versions of Foo.

So history becomes incomplete.

ğŸ§  Example Scenario

You have:

Bar â†’ has many Foo

You audit only Bar.

Now:

You change Foo.name.

Question:

Will history reflect Foo name changes?

Answer: âŒ No.

Because Foo is not audited.

ğŸ¯ So When Should You Audit Both?

If:

Both entities contain business-critical data

You need history for both

You want consistent relationship history

Then yes â€” audit both.

ğŸ§  When Is It Fine to Audit Only One?

If:

Foo is small

Foo data is not important historically

Only Bar changes matter

Then auditing only Bar is fine.

ğŸ§  Clean Rule
Auditing is per-entity.
It is NOT automatically cascaded through relationships.


Each entity must explicitly have:

@Audited


if you want its history tracked.

ğŸ”¥ Advanced Note

Envers allows:

@Audited(targetAuditMode = RelationTargetAuditMode.NOT_AUDITED)


Which means:

Audit this entity, but donâ€™t require the target entity to be audited.

So relationship auditing is configurable.

ğŸ¯ Final Answer to Your Question

No, auditing one entity does not automatically audit related entities.
If you want history tracking for both entities, you must annotate both with @Audited


----
Spring data jpa
----

built on top of jpa .. does same things using prebuilt callbacks..