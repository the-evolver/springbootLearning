ğŸ§  First â€” What Is Actually Happening When /posts/9(means posts which is not present) Is Called?

Letâ€™s assume:

There is NO post with id = 9.

ğŸ” Step 1 â€” Request Comes In

Client calls:

GET /posts/9


Spring does:

Controller â†’ Service â†’ Repository

ğŸ” Step 2 â€” Repository
postRepository.findById(9)


Returns:

Optional.empty()


Because no row exists.

ğŸ” Step 3 â€” Service
.orElseThrow(...)

This line executes.

Since Optional is empty:

â†’ It THROWS an exception.

Letâ€™s say:

new ResourceNotFoundException("Post", "id", 9)


Boom ğŸ’¥
Execution stops immediately.

Nothing after that line runs.

ğŸš¨ Now Important Question

Where does this exception go?

It starts going UP the call stack.

Like this:

Repository
  â†‘
Service
  â†‘
Controller
  â†‘
Spring DispatcherServlet

ğŸ§  If We Did NOTHING

Spring sees:

"Some runtime exception happened"

So it says:

Server error.

And returns:

500 Internal Server Error


Because Spring does not know what that exception means.

ğŸ”¥ Now Where Does @RestControllerAdvice Come In?

Think of it like this:

Spring has a global try-catch mechanism.

Very important:

Spring internally wraps controller execution in something like:

try {
    controllerMethod();
}
catch (Exception e) {
    handleException(e);
}


That handleException(e) part looks for:

Any class annotated with @ControllerAdvice or @RestControllerAdvice

Any method annotated with @ExceptionHandler(SomeException.class)

ğŸ§© So When Exception Is Thrown

Flow becomes:

Controller
   â†“
Service
   â†“
Repository
   â†“
Exception Thrown
   â†‘
Spring catches it
   â†“
Looks for matching @ExceptionHandler
   â†“
Calls that method
   â†“
Returns ResponseEntity

ğŸ¯ Letâ€™s Visualize It Clearly
WITHOUT Global Advice
Client â†’ Controller â†’ Service â†’ Exception
                           â†‘
                       Nobody catches
                           â†‘
                   Spring default handler
                           â†‘
                    500 Internal Server Error

WITH Global Advice
Client â†’ Controller â†’ Service â†’ Exception
                           â†‘
                    Spring catches it
                           â†‘
         Finds @ExceptionHandler(ResourceNotFoundException)
                           â†‘
               Calls your method in GlobalExceptionHandler
                           â†‘
                Returns custom 404 response

ğŸ”¥ Now Letâ€™s See Concrete Code Flow
Step A â€” Exception Thrown
.orElseThrow(() ->
        new ResourceNotFoundException("Post", "id", postId)
);


This creates:

ResourceNotFoundException

Step B â€” Spring Sees This Class

You wrote:

@RestControllerAdvice
public class GlobalExceptionHandler


Spring scans this at startup.

It registers:

â€œIf any controller throws ResourceNotFoundException, call this method.â€

Step C â€” Exception Handler Method
@ExceptionHandler(ResourceNotFoundException.class)
public ResponseEntity<ErrorDetails> handleResourceNotFound(
        ResourceNotFoundException ex) {


Spring matches:

Exception type = ResourceNotFoundException
Handler expects = ResourceNotFoundException

Match found âœ…

Spring calls this method.

Step D â€” Your Handler Returns
return new ResponseEntity<>(error, HttpStatus.NOT_FOUND);


Now Spring says:

Oh, you want to send 404.

So it builds:

HTTP 404
JSON body = ErrorDetails


And sends to client.

ğŸ§  IMPORTANT

You did NOT call this method manually.

Spring calls it automatically because:

It is annotated

It matches exception type

It is global advice

ğŸ§  Why Is It Called â€œAdviceâ€?

Because it â€œadvisesâ€ the controller globally.

It acts like:

A global interceptor for exceptions.

ğŸ”¥ Real Life Analogy

Imagine:

Controller = Office worker
Service = Assistant
Exception = Complaint

Without Advice:

Complaint reaches office â†’ Nobody knows what to do â†’ Panic â†’ 500

With Advice:

Complaint reaches office â†’ Reception desk (Advice) handles it properly â†’ Sends correct response

ğŸ§  End-to-End Flow in One Line
Exception thrown â†’ Spring catches â†’ matches handler â†’ handler returns ResponseEntity â†’ client receives formatted HTTP response


ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥

Auditing

ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥




